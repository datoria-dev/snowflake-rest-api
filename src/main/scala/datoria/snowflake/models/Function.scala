/** merged spec
  * merged spec
  *
  * The version of the OpenAPI document: 1.0.0
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package datoria.snowflake.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}

import java.time.Instant
import scala.collection.immutable.Seq

/** A Snowflake function
  * @param functionType 
  * @param name Specifies the name for the function, must be unique for the schema in which the function is created
  * @param arguments 
  * @param returns 
  * @param maxBatchRows Specifies the max rows for batch operation.
  * @param createdOn Date and time when the function was created.
  * @param signature Function's arguments.
  * @param language Function's language.
  * @param body Function's body.
  */
case class Function(
    functionType: Option[String] = None,
    name: String,
    arguments: Seq[FunctionArgument],
    returns: Option[FunctionReturns] = None,
    maxBatchRows: Option[Int] = None,
    createdOn: Option[Instant] = None,
    signature: Option[String] = None,
    language: Option[String] = None,
    body: Option[String] = None
)
  
object Function {
  given encoderFunction: Encoder[Function] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        t.functionType.map(v => "function_type" -> v.asJson),
        Some("name" -> t.name.asJson),
        Some("arguments" -> t.arguments.asJson),
        t.returns.map(v => "returns" -> v.asJson),
        t.maxBatchRows.map(v => "max_batch_rows" -> v.asJson),
        t.createdOn.map(v => "created_on" -> v.asJson),
        t.signature.map(v => "signature" -> v.asJson),
        t.language.map(v => "language" -> v.asJson),
        t.body.map(v => "body" -> v.asJson)
      ).flatten
    }
  }
  given decoderFunction: Decoder[Function] = Decoder.instance { c =>
    for {
      functionType <- c.downField("function_type").as[Option[String]]
      name <- c.downField("name").as[String]
      arguments <- c.downField("arguments").as[Seq[FunctionArgument]]
      returns <- c.downField("returns").as[Option[FunctionReturns]]
      maxBatchRows <- c.downField("max_batch_rows").as[Option[Int]]
      createdOn <- c.downField("created_on").as[Option[Instant]]
      signature <- c.downField("signature").as[Option[String]]
      language <- c.downField("language").as[Option[String]]
      body <- c.downField("body").as[Option[String]]
    } yield Function(
      functionType = functionType,
      name = name,
      arguments = arguments,
      returns = returns,
      maxBatchRows = maxBatchRows,
      createdOn = createdOn,
      signature = signature,
      language = language,
      body = body
    )
  }
}

