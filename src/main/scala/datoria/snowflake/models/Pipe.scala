/** merged spec
  * merged spec
  *
  * The version of the OpenAPI document: 1.0.0
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package datoria.snowflake.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}

import java.time.Instant

/** A Snowflake pipe
  * @param name Name of the pipe
  * @param comment user comment associated to an object in the dictionary
  * @param autoIngest TRUE if all files from stage need to be auto-ingested
  * @param errorIntegration Link to integration object that point to a user provided Azure storage queue / SQS. When present,  errors (e.g. ingest failure for Snowpipe or a user task failure or replication failure) will be sent to this queue to notify customers
  * @param awsSnsTopic Optional, if provided, auto_ingest pipe will only receive messages from this SNS topic.
  * @param integration Link to integration object that ties a user provided storage queue to an auto_ingest enabled pipe. Required for auto_ingest to work on azure.
  * @param copyStatement COPY INTO <table> statement used to load data from queued files into a Snowflake table. This statement serves as the text/definition for the pipe and is displayed in the SHOW PIPES output
  * @param createdOn Date and time when the pipe was created.
  * @param databaseName Database in which the pipe is stored
  * @param schemaName Schema in which the pipe is stored
  * @param owner Role that owns the pipe
  * @param pattern PATTERN copy option value in the COPY INTO <table> statement in the pipe definition, if the copy option was specified.
  * @param ownerRoleType The type of role that owns the pipe
  * @param invalidReason Displays some detailed information for your pipes that may have issues
  * @param budget Name of the budget if the pipe is monitored by a budget
  */
case class Pipe(
    name: String,
    comment: Option[String] = None,
    autoIngest: Option[Boolean] = None,
    errorIntegration: Option[String] = None,
    awsSnsTopic: Option[String] = None,
    integration: Option[String] = None,
    copyStatement: String,
    createdOn: Option[Instant] = None,
    databaseName: Option[String] = None,
    schemaName: Option[String] = None,
    owner: Option[String] = None,
    pattern: Option[String] = None,
    ownerRoleType: Option[String] = None,
    invalidReason: Option[String] = None,
    budget: Option[String] = None
)
  
object Pipe {
  given encoderPipe: Encoder[Pipe] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        Some("name" -> t.name.asJson),
        t.comment.map(v => "comment" -> v.asJson),
        t.autoIngest.map(v => "auto_ingest" -> v.asJson),
        t.errorIntegration.map(v => "error_integration" -> v.asJson),
        t.awsSnsTopic.map(v => "aws_sns_topic" -> v.asJson),
        t.integration.map(v => "integration" -> v.asJson),
        Some("copy_statement" -> t.copyStatement.asJson),
        t.createdOn.map(v => "created_on" -> v.asJson),
        t.databaseName.map(v => "database_name" -> v.asJson),
        t.schemaName.map(v => "schema_name" -> v.asJson),
        t.owner.map(v => "owner" -> v.asJson),
        t.pattern.map(v => "pattern" -> v.asJson),
        t.ownerRoleType.map(v => "owner_role_type" -> v.asJson),
        t.invalidReason.map(v => "invalid_reason" -> v.asJson),
        t.budget.map(v => "budget" -> v.asJson)
      ).flatten
    }
  }
  given decoderPipe: Decoder[Pipe] = Decoder.instance { c =>
    for {
      name <- c.downField("name").as[String]
      comment <- c.downField("comment").as[Option[String]]
      autoIngest <- c.downField("auto_ingest").as[Option[Boolean]]
      errorIntegration <- c.downField("error_integration").as[Option[String]]
      awsSnsTopic <- c.downField("aws_sns_topic").as[Option[String]]
      integration <- c.downField("integration").as[Option[String]]
      copyStatement <- c.downField("copy_statement").as[String]
      createdOn <- c.downField("created_on").as[Option[Instant]]
      databaseName <- c.downField("database_name").as[Option[String]]
      schemaName <- c.downField("schema_name").as[Option[String]]
      owner <- c.downField("owner").as[Option[String]]
      pattern <- c.downField("pattern").as[Option[String]]
      ownerRoleType <- c.downField("owner_role_type").as[Option[String]]
      invalidReason <- c.downField("invalid_reason").as[Option[String]]
      budget <- c.downField("budget").as[Option[String]]
    } yield Pipe(
      name = name,
      comment = comment,
      autoIngest = autoIngest,
      errorIntegration = errorIntegration,
      awsSnsTopic = awsSnsTopic,
      integration = integration,
      copyStatement = copyStatement,
      createdOn = createdOn,
      databaseName = databaseName,
      schemaName = schemaName,
      owner = owner,
      pattern = pattern,
      ownerRoleType = ownerRoleType,
      invalidReason = invalidReason,
      budget = budget
    )
  }
}

