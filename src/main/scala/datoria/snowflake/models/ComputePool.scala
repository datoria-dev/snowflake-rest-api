/** merged spec
  * merged spec
  *
  * The version of the OpenAPI document: 1.0.0
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package datoria.snowflake.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}

import java.time.Instant

/** A Snowflake compute pool definition.
  * @param name A Snowflake object identifier.
  * @param minNodes Minimum number of nodes for the compute pool.
  * @param maxNodes Maximum number of nodes for the compute pool.
  * @param instanceFamily Instance family for the compute pool.
  * @param autoResume Whether Snowflake automatically resumes the compute pool when any statement that requires the compute pool is submitted.
  * @param comment Comment describing the compute pool.
  * @param state 
  * @param numServices Number of services on the compute pool.
  * @param numJobs Number of jobs on the compute pool.
  * @param autoSuspendSecs Number of seconds until the compute pool automatically suspends.
  * @param activeNodes Number of currently active nodes on the compute pool.
  * @param idleNodes Number of currently idle nodes on the compute pool.
  * @param targetNodes Number of target nodes on the compute pool.
  * @param createdOn Time the compute pool was created.
  * @param resumedOn Time the compute pool was last resumed.
  * @param updatedOn Time the compute pool was last updated.
  * @param owner Identifier for the current owner of the compute pool.
  * @param isExclusive Whether a compute pool is created exclusively for a Snowflake Native App.
  * @param application Name of the Snowflake Native App if the compute pool is created exclusively for the app.
  * @param budget The name of the budget monitoring the credit usage of the compute pool.
  * @param errorCode Current error the compute pool hit if any.
  * @param statusMessage Current status of the compute pool if any.
  */
case class ComputePool(
    name: String,
    minNodes: Int,
    maxNodes: Int,
    instanceFamily: String,
    autoResume: Option[Boolean] = None,
    comment: Option[String] = None,
    state: Option[ComputePoolState] = None,
    numServices: Option[Int] = None,
    numJobs: Option[Int] = None,
    autoSuspendSecs: Option[Long] = None,
    activeNodes: Option[Int] = None,
    idleNodes: Option[Int] = None,
    targetNodes: Option[Int] = None,
    createdOn: Option[Instant] = None,
    resumedOn: Option[Instant] = None,
    updatedOn: Option[Instant] = None,
    owner: Option[String] = None,
    isExclusive: Option[Boolean] = None,
    application: Option[String] = None,
    budget: Option[String] = None,
    errorCode: Option[String] = None,
    statusMessage: Option[String] = None
)
  
object ComputePool {
  given encoderComputePool: Encoder[ComputePool] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        Some("name" -> t.name.asJson),
        Some("min_nodes" -> t.minNodes.asJson),
        Some("max_nodes" -> t.maxNodes.asJson),
        Some("instance_family" -> t.instanceFamily.asJson),
        t.autoResume.map(v => "auto_resume" -> v.asJson),
        t.comment.map(v => "comment" -> v.asJson),
        t.state.map(v => "state" -> v.asJson),
        t.numServices.map(v => "num_services" -> v.asJson),
        t.numJobs.map(v => "num_jobs" -> v.asJson),
        t.autoSuspendSecs.map(v => "auto_suspend_secs" -> v.asJson),
        t.activeNodes.map(v => "active_nodes" -> v.asJson),
        t.idleNodes.map(v => "idle_nodes" -> v.asJson),
        t.targetNodes.map(v => "target_nodes" -> v.asJson),
        t.createdOn.map(v => "created_on" -> v.asJson),
        t.resumedOn.map(v => "resumed_on" -> v.asJson),
        t.updatedOn.map(v => "updated_on" -> v.asJson),
        t.owner.map(v => "owner" -> v.asJson),
        t.isExclusive.map(v => "is_exclusive" -> v.asJson),
        t.application.map(v => "application" -> v.asJson),
        t.budget.map(v => "budget" -> v.asJson),
        t.errorCode.map(v => "error_code" -> v.asJson),
        t.statusMessage.map(v => "status_message" -> v.asJson)
      ).flatten
    }
  }
  given decoderComputePool: Decoder[ComputePool] = Decoder.instance { c =>
    for {
      name <- c.downField("name").as[String]
      minNodes <- c.downField("min_nodes").as[Int]
      maxNodes <- c.downField("max_nodes").as[Int]
      instanceFamily <- c.downField("instance_family").as[String]
      autoResume <- c.downField("auto_resume").as[Option[Boolean]]
      comment <- c.downField("comment").as[Option[String]]
      state <- c.downField("state").as[Option[ComputePoolState]]
      numServices <- c.downField("num_services").as[Option[Int]]
      numJobs <- c.downField("num_jobs").as[Option[Int]]
      autoSuspendSecs <- c.downField("auto_suspend_secs").as[Option[Long]]
      activeNodes <- c.downField("active_nodes").as[Option[Int]]
      idleNodes <- c.downField("idle_nodes").as[Option[Int]]
      targetNodes <- c.downField("target_nodes").as[Option[Int]]
      createdOn <- c.downField("created_on").as[Option[Instant]]
      resumedOn <- c.downField("resumed_on").as[Option[Instant]]
      updatedOn <- c.downField("updated_on").as[Option[Instant]]
      owner <- c.downField("owner").as[Option[String]]
      isExclusive <- c.downField("is_exclusive").as[Option[Boolean]]
      application <- c.downField("application").as[Option[String]]
      budget <- c.downField("budget").as[Option[String]]
      errorCode <- c.downField("error_code").as[Option[String]]
      statusMessage <- c.downField("status_message").as[Option[String]]
    } yield ComputePool(
      name = name,
      minNodes = minNodes,
      maxNodes = maxNodes,
      instanceFamily = instanceFamily,
      autoResume = autoResume,
      comment = comment,
      state = state,
      numServices = numServices,
      numJobs = numJobs,
      autoSuspendSecs = autoSuspendSecs,
      activeNodes = activeNodes,
      idleNodes = idleNodes,
      targetNodes = targetNodes,
      createdOn = createdOn,
      resumedOn = resumedOn,
      updatedOn = updatedOn,
      owner = owner,
      isExclusive = isExclusive,
      application = application,
      budget = budget,
      errorCode = errorCode,
      statusMessage = statusMessage
    )
  }
}

