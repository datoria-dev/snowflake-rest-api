/** merged spec
  * merged spec
  *
  * The version of the OpenAPI document: 1.0.0
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package datoria.snowflake.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}

import java.time.Instant

/** A Snowflake virtual warehouse
  * @param name A Snowflake object identifier.
  * @param warehouseType Type of warehouse, possible types: STANDARD, SNOWPARK-OPTIMIZED
  * @param warehouseSize Size of warehouse, possible sizes: XSMALL, SMALL, MEDIUM, LARGE, XLARGE, XXLARGE, XXXLARGE, X4LARGE, X5LARGE, X6LARGE
  * @param waitForCompletion 
  * @param maxClusterCount Specifies the maximum number of clusters for a multi-cluster warehouse
  * @param minClusterCount Specifies the minimum number of clusters for a multi-cluster warehouse
  * @param scalingPolicy Scaling policy of warehouse, possible scaling policies: STANDARD, ECONOMY
  * @param autoSuspend time in seconds before auto suspend
  * @param autoResume 
  * @param initiallySuspended 
  * @param resourceMonitor A Snowflake object identifier.
  * @param comment Specifies a comment for the warehouse
  * @param enableQueryAcceleration 
  * @param queryAccelerationMaxScaleFactor Specifies the maximum scale factor for leasing compute resources for query acceleration. The scale factor is used as a multiplier based on warehouse size
  * @param maxConcurrencyLevel Object parameter that specifies the concurrency level for SQL statements executed by a warehouse cluster
  * @param statementQueuedTimeoutInSeconds Object parameter that specifies the time, in seconds, a SQL statement can be queued on a warehouse before it is canceled by the system
  * @param statementTimeoutInSeconds Object parameter that specifies the time, in seconds, after which a running SQL statement  is canceled by the system
  * @param `type` [Deprecated] Type of warehouse, possible types: STANDARD, SNOWPARK-OPTIMIZED
  * @param size [Deprecated] names of size: X-Small, Small, Medium, Large, X-Large, 2X-Large, 3X-Large, 4X-Large, 5X-Large, 6X-Large
  * @param state The state of warehouse, possible states: STARTED, STARTING, DYNAMIC, SUSPENDED, RESIZING, RESUMING, SUSPENDING
  * @param startedClusters Number of clusters currently started.
  * @param running Number of SQL statements that are being executed by the warehouse.
  * @param queued Number of SQL statements that are queued for the warehouse.
  * @param isDefault Whether the warehouse is the default for the current user.
  * @param isCurrent Whether the warehouse is in use for the session. Only one warehouse can be in use at a time for a session.  To specify or change the warehouse for a session, use the USE WAREHOUSE command.
  * @param available Percentage of the warehouse compute resources that are provisioned and available.
  * @param provisioning Percentage of the warehouse compute resources that are in the process of provisioning.
  * @param quiescing Percentage of the warehouse compute resources that are executing SQL statements,  but will be shut down once the queries complete.
  * @param other Percentage of the warehouse compute resources that are in a state other than available,  provisioning, or quiescing.
  * @param createdOn Date and time when the warehouse was created.
  * @param resumedOn Date and time when the warehouse was last started or restarted.
  * @param updatedOn Date and time when the warehouse was last updated,  which includes changing any of the properties of the warehouse or changing the state (STARTED, SUSPENDED, RESIZING) of the warehouse.
  * @param owner Role that owns the warehouse.
  * @param budget Comment representing budget for warehouse.
  * @param kind 
  * @param ownerRoleType The type of role that owns the object.
  */
case class Warehouse(
    name: String,
    warehouseType: Option[String] = None,
    warehouseSize: Option[String] = None,
    waitForCompletion: Option[WarehouseWaitForCompletion] = None,
    maxClusterCount: Option[Int] = None,
    minClusterCount: Option[Int] = None,
    scalingPolicy: Option[String] = None,
    autoSuspend: Option[Int] = None,
    autoResume: Option[WarehouseAutoResume] = None,
    initiallySuspended: Option[WarehouseInitiallySuspended] = None,
    resourceMonitor: Option[String] = None,
    comment: Option[String] = None,
    enableQueryAcceleration: Option[WarehouseEnableQueryAcceleration] = None,
    queryAccelerationMaxScaleFactor: Option[Int] = None,
    maxConcurrencyLevel: Option[Int] = None,
    statementQueuedTimeoutInSeconds: Option[Int] = None,
    statementTimeoutInSeconds: Option[Int] = None,
    `type`: Option[String] = None,
    size: Option[String] = None,
    state: Option[String] = None,
    startedClusters: Option[Int] = None,
    running: Option[Int] = None,
    queued: Option[Int] = None,
    isDefault: Option[Boolean] = None,
    isCurrent: Option[Boolean] = None,
    available: Option[String] = None,
    provisioning: Option[String] = None,
    quiescing: Option[String] = None,
    other: Option[String] = None,
    createdOn: Option[Instant] = None,
    resumedOn: Option[Instant] = None,
    updatedOn: Option[Instant] = None,
    owner: Option[String] = None,
    budget: Option[String] = None,
    kind: Option[String] = None,
    ownerRoleType: Option[String] = None
)
  
object Warehouse {
  given encoderWarehouse: Encoder[Warehouse] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        Some("name" -> t.name.asJson),
        t.warehouseType.map(v => "warehouse_type" -> v.asJson),
        t.warehouseSize.map(v => "warehouse_size" -> v.asJson),
        t.waitForCompletion.map(v => "wait_for_completion" -> v.asJson),
        t.maxClusterCount.map(v => "max_cluster_count" -> v.asJson),
        t.minClusterCount.map(v => "min_cluster_count" -> v.asJson),
        t.scalingPolicy.map(v => "scaling_policy" -> v.asJson),
        t.autoSuspend.map(v => "auto_suspend" -> v.asJson),
        t.autoResume.map(v => "auto_resume" -> v.asJson),
        t.initiallySuspended.map(v => "initially_suspended" -> v.asJson),
        t.resourceMonitor.map(v => "resource_monitor" -> v.asJson),
        t.comment.map(v => "comment" -> v.asJson),
        t.enableQueryAcceleration.map(v => "enable_query_acceleration" -> v.asJson),
        t.queryAccelerationMaxScaleFactor.map(v => "query_acceleration_max_scale_factor" -> v.asJson),
        t.maxConcurrencyLevel.map(v => "max_concurrency_level" -> v.asJson),
        t.statementQueuedTimeoutInSeconds.map(v => "statement_queued_timeout_in_seconds" -> v.asJson),
        t.statementTimeoutInSeconds.map(v => "statement_timeout_in_seconds" -> v.asJson),
        t.`type`.map(v => "type" -> v.asJson),
        t.size.map(v => "size" -> v.asJson),
        t.state.map(v => "state" -> v.asJson),
        t.startedClusters.map(v => "started_clusters" -> v.asJson),
        t.running.map(v => "running" -> v.asJson),
        t.queued.map(v => "queued" -> v.asJson),
        t.isDefault.map(v => "is_default" -> v.asJson),
        t.isCurrent.map(v => "is_current" -> v.asJson),
        t.available.map(v => "available" -> v.asJson),
        t.provisioning.map(v => "provisioning" -> v.asJson),
        t.quiescing.map(v => "quiescing" -> v.asJson),
        t.other.map(v => "other" -> v.asJson),
        t.createdOn.map(v => "created_on" -> v.asJson),
        t.resumedOn.map(v => "resumed_on" -> v.asJson),
        t.updatedOn.map(v => "updated_on" -> v.asJson),
        t.owner.map(v => "owner" -> v.asJson),
        t.budget.map(v => "budget" -> v.asJson),
        t.kind.map(v => "kind" -> v.asJson),
        t.ownerRoleType.map(v => "owner_role_type" -> v.asJson)
      ).flatten
    }
  }
  given decoderWarehouse: Decoder[Warehouse] = Decoder.instance { c =>
    for {
      name <- c.downField("name").as[String]
      warehouseType <- c.downField("warehouse_type").as[Option[String]]
      warehouseSize <- c.downField("warehouse_size").as[Option[String]]
      waitForCompletion <- c.downField("wait_for_completion").as[Option[WarehouseWaitForCompletion]]
      maxClusterCount <- c.downField("max_cluster_count").as[Option[Int]]
      minClusterCount <- c.downField("min_cluster_count").as[Option[Int]]
      scalingPolicy <- c.downField("scaling_policy").as[Option[String]]
      autoSuspend <- c.downField("auto_suspend").as[Option[Int]]
      autoResume <- c.downField("auto_resume").as[Option[WarehouseAutoResume]]
      initiallySuspended <- c.downField("initially_suspended").as[Option[WarehouseInitiallySuspended]]
      resourceMonitor <- c.downField("resource_monitor").as[Option[String]]
      comment <- c.downField("comment").as[Option[String]]
      enableQueryAcceleration <- c.downField("enable_query_acceleration").as[Option[WarehouseEnableQueryAcceleration]]
      queryAccelerationMaxScaleFactor <- c.downField("query_acceleration_max_scale_factor").as[Option[Int]]
      maxConcurrencyLevel <- c.downField("max_concurrency_level").as[Option[Int]]
      statementQueuedTimeoutInSeconds <- c.downField("statement_queued_timeout_in_seconds").as[Option[Int]]
      statementTimeoutInSeconds <- c.downField("statement_timeout_in_seconds").as[Option[Int]]
      `type` <- c.downField("type").as[Option[String]]
      size <- c.downField("size").as[Option[String]]
      state <- c.downField("state").as[Option[String]]
      startedClusters <- c.downField("started_clusters").as[Option[Int]]
      running <- c.downField("running").as[Option[Int]]
      queued <- c.downField("queued").as[Option[Int]]
      isDefault <- c.downField("is_default").as[Option[Boolean]]
      isCurrent <- c.downField("is_current").as[Option[Boolean]]
      available <- c.downField("available").as[Option[String]]
      provisioning <- c.downField("provisioning").as[Option[String]]
      quiescing <- c.downField("quiescing").as[Option[String]]
      other <- c.downField("other").as[Option[String]]
      createdOn <- c.downField("created_on").as[Option[Instant]]
      resumedOn <- c.downField("resumed_on").as[Option[Instant]]
      updatedOn <- c.downField("updated_on").as[Option[Instant]]
      owner <- c.downField("owner").as[Option[String]]
      budget <- c.downField("budget").as[Option[String]]
      kind <- c.downField("kind").as[Option[String]]
      ownerRoleType <- c.downField("owner_role_type").as[Option[String]]
    } yield Warehouse(
      name = name,
      warehouseType = warehouseType,
      warehouseSize = warehouseSize,
      waitForCompletion = waitForCompletion,
      maxClusterCount = maxClusterCount,
      minClusterCount = minClusterCount,
      scalingPolicy = scalingPolicy,
      autoSuspend = autoSuspend,
      autoResume = autoResume,
      initiallySuspended = initiallySuspended,
      resourceMonitor = resourceMonitor,
      comment = comment,
      enableQueryAcceleration = enableQueryAcceleration,
      queryAccelerationMaxScaleFactor = queryAccelerationMaxScaleFactor,
      maxConcurrencyLevel = maxConcurrencyLevel,
      statementQueuedTimeoutInSeconds = statementQueuedTimeoutInSeconds,
      statementTimeoutInSeconds = statementTimeoutInSeconds,
      `type` = `type`,
      size = size,
      state = state,
      startedClusters = startedClusters,
      running = running,
      queued = queued,
      isDefault = isDefault,
      isCurrent = isCurrent,
      available = available,
      provisioning = provisioning,
      quiescing = quiescing,
      other = other,
      createdOn = createdOn,
      resumedOn = resumedOn,
      updatedOn = updatedOn,
      owner = owner,
      budget = budget,
      kind = kind,
      ownerRoleType = ownerRoleType
    )
  }
}

