/** merged spec
  * merged spec
  *
  * The version of the OpenAPI document: 1.0.0
  * Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech
  * Do not edit the class manually.
  */
package datoria.snowflake.models

import io.circe.*
import io.circe.syntax.*
import io.circe.{Decoder, Encoder}

import java.time.Instant

/** Properties of user.
  * @param name User name
  * @param password Password
  * @param loginName Login name
  * @param displayName Display name
  * @param firstName First name
  * @param middleName Middle name
  * @param lastName Last name
  * @param email Email address
  * @param mustChangePassword Does this user need to change their password (e.g., after assigning a temp password)
  * @param disabled Has this user been disabled from the system
  * @param daysToExpiry How many days until this user expires
  * @param minsToUnlock How many minutes until the account is unlocked after multiple failed logins
  * @param defaultWarehouse The default warehouse to use when this user starts a session
  * @param defaultNamespace The default namespace to use when this user starts a session
  * @param defaultRole The default role to use when this user starts a session
  * @param defaultSecondaryRoles 
  * @param minsToBypassMfa How many minutes until MFA is required again
  * @param rsaPublicKey RSA public key of the user
  * @param rsaPublicKey2 Second RSA public key of the user
  * @param comment Comment about the user.
  * @param `type` Indicates the type of user (PERSON | SERVICE | LEGACY_SERVICE)
  * @param enableUnredactedQuerySyntaxError Whether to show unredacted query syntax errors in the query history.
  * @param networkPolicy Specifies an existing network policy is active for the user. Otherwise, use account default.
  * @param createdOn 
  * @param lastSuccessfulLogin 
  * @param expiresAt 
  * @param lockedUntil 
  * @param hasPassword 
  * @param hasRsaPublicKey 
  * @param rsaPublicKeyFp Fingerprint of the user's RSA public key
  * @param rsaPublicKey2Fp Fingerprint of the user's second RSA public key
  * @param extAuthnDuo 
  * @param extAuthnUid 
  * @param owner 
  * @param snowflakeLock Whether the user, account, or organization is locked by Snowflake.
  * @param snowflakeSupport Whether Snowflake Support is allowed to use the user or account
  * @param minsToBypassNetworkPolicy Temporary bypass network policy on the user for a specified number of minutes
  * @param passwordLastSet 
  * @param customLandingPageUrl 
  * @param customLandingPageUrlFlushNextUiLoad Whether or not to flush the custom landing page of the user on next UI load
  */
case class User(
    name: String,
    password: Option[String] = None,
    loginName: Option[String] = None,
    displayName: Option[String] = None,
    firstName: Option[String] = None,
    middleName: Option[String] = None,
    lastName: Option[String] = None,
    email: Option[String] = None,
    mustChangePassword: Option[Boolean] = None,
    disabled: Option[Boolean] = None,
    daysToExpiry: Option[Int] = None,
    minsToUnlock: Option[Int] = None,
    defaultWarehouse: Option[String] = None,
    defaultNamespace: Option[String] = None,
    defaultRole: Option[String] = None,
    defaultSecondaryRoles: Option[UserDefaultSecondaryRoles] = None,
    minsToBypassMfa: Option[Int] = None,
    rsaPublicKey: Option[String] = None,
    rsaPublicKey2: Option[String] = None,
    comment: Option[String] = None,
    `type`: Option[String] = None,
    enableUnredactedQuerySyntaxError: Option[Boolean] = None,
    networkPolicy: Option[String] = None,
    createdOn: Option[Instant] = None,
    lastSuccessfulLogin: Option[Instant] = None,
    expiresAt: Option[Instant] = None,
    lockedUntil: Option[Instant] = None,
    hasPassword: Option[Boolean] = None,
    hasRsaPublicKey: Option[Boolean] = None,
    rsaPublicKeyFp: Option[String] = None,
    rsaPublicKey2Fp: Option[String] = None,
    extAuthnDuo: Option[Boolean] = None,
    extAuthnUid: Option[String] = None,
    owner: Option[String] = None,
    snowflakeLock: Option[Boolean] = None,
    snowflakeSupport: Option[Boolean] = None,
    minsToBypassNetworkPolicy: Option[Int] = None,
    passwordLastSet: Option[Instant] = None,
    customLandingPageUrl: Option[String] = None,
    customLandingPageUrlFlushNextUiLoad: Option[Boolean] = None
)
  
object User {
  given encoderUser: Encoder[User] = Encoder.instance { t =>
    Json.fromFields{
      Seq(
        Some("name" -> t.name.asJson),
        t.password.map(v => "password" -> v.asJson),
        t.loginName.map(v => "login_name" -> v.asJson),
        t.displayName.map(v => "display_name" -> v.asJson),
        t.firstName.map(v => "first_name" -> v.asJson),
        t.middleName.map(v => "middle_name" -> v.asJson),
        t.lastName.map(v => "last_name" -> v.asJson),
        t.email.map(v => "email" -> v.asJson),
        t.mustChangePassword.map(v => "must_change_password" -> v.asJson),
        t.disabled.map(v => "disabled" -> v.asJson),
        t.daysToExpiry.map(v => "days_to_expiry" -> v.asJson),
        t.minsToUnlock.map(v => "mins_to_unlock" -> v.asJson),
        t.defaultWarehouse.map(v => "default_warehouse" -> v.asJson),
        t.defaultNamespace.map(v => "default_namespace" -> v.asJson),
        t.defaultRole.map(v => "default_role" -> v.asJson),
        t.defaultSecondaryRoles.map(v => "default_secondary_roles" -> v.asJson),
        t.minsToBypassMfa.map(v => "mins_to_bypass_mfa" -> v.asJson),
        t.rsaPublicKey.map(v => "rsa_public_key" -> v.asJson),
        t.rsaPublicKey2.map(v => "rsa_public_key_2" -> v.asJson),
        t.comment.map(v => "comment" -> v.asJson),
        t.`type`.map(v => "type" -> v.asJson),
        t.enableUnredactedQuerySyntaxError.map(v => "enable_unredacted_query_syntax_error" -> v.asJson),
        t.networkPolicy.map(v => "network_policy" -> v.asJson),
        t.createdOn.map(v => "created_on" -> v.asJson),
        t.lastSuccessfulLogin.map(v => "last_successful_login" -> v.asJson),
        t.expiresAt.map(v => "expires_at" -> v.asJson),
        t.lockedUntil.map(v => "locked_until" -> v.asJson),
        t.hasPassword.map(v => "has_password" -> v.asJson),
        t.hasRsaPublicKey.map(v => "has_rsa_public_key" -> v.asJson),
        t.rsaPublicKeyFp.map(v => "rsa_public_key_fp" -> v.asJson),
        t.rsaPublicKey2Fp.map(v => "rsa_public_key_2_fp" -> v.asJson),
        t.extAuthnDuo.map(v => "ext_authn_duo" -> v.asJson),
        t.extAuthnUid.map(v => "ext_authn_uid" -> v.asJson),
        t.owner.map(v => "owner" -> v.asJson),
        t.snowflakeLock.map(v => "snowflake_lock" -> v.asJson),
        t.snowflakeSupport.map(v => "snowflake_support" -> v.asJson),
        t.minsToBypassNetworkPolicy.map(v => "mins_to_bypass_network_policy" -> v.asJson),
        t.passwordLastSet.map(v => "password_last_set" -> v.asJson),
        t.customLandingPageUrl.map(v => "custom_landing_page_url" -> v.asJson),
        t.customLandingPageUrlFlushNextUiLoad.map(v => "custom_landing_page_url_flush_next_ui_load" -> v.asJson)
      ).flatten
    }
  }
  given decoderUser: Decoder[User] = Decoder.instance { c =>
    for {
      name <- c.downField("name").as[String]
      password <- c.downField("password").as[Option[String]]
      loginName <- c.downField("login_name").as[Option[String]]
      displayName <- c.downField("display_name").as[Option[String]]
      firstName <- c.downField("first_name").as[Option[String]]
      middleName <- c.downField("middle_name").as[Option[String]]
      lastName <- c.downField("last_name").as[Option[String]]
      email <- c.downField("email").as[Option[String]]
      mustChangePassword <- c.downField("must_change_password").as[Option[Boolean]]
      disabled <- c.downField("disabled").as[Option[Boolean]]
      daysToExpiry <- c.downField("days_to_expiry").as[Option[Int]]
      minsToUnlock <- c.downField("mins_to_unlock").as[Option[Int]]
      defaultWarehouse <- c.downField("default_warehouse").as[Option[String]]
      defaultNamespace <- c.downField("default_namespace").as[Option[String]]
      defaultRole <- c.downField("default_role").as[Option[String]]
      defaultSecondaryRoles <- c.downField("default_secondary_roles").as[Option[UserDefaultSecondaryRoles]]
      minsToBypassMfa <- c.downField("mins_to_bypass_mfa").as[Option[Int]]
      rsaPublicKey <- c.downField("rsa_public_key").as[Option[String]]
      rsaPublicKey2 <- c.downField("rsa_public_key_2").as[Option[String]]
      comment <- c.downField("comment").as[Option[String]]
      `type` <- c.downField("type").as[Option[String]]
      enableUnredactedQuerySyntaxError <- c.downField("enable_unredacted_query_syntax_error").as[Option[Boolean]]
      networkPolicy <- c.downField("network_policy").as[Option[String]]
      createdOn <- c.downField("created_on").as[Option[Instant]]
      lastSuccessfulLogin <- c.downField("last_successful_login").as[Option[Instant]]
      expiresAt <- c.downField("expires_at").as[Option[Instant]]
      lockedUntil <- c.downField("locked_until").as[Option[Instant]]
      hasPassword <- c.downField("has_password").as[Option[Boolean]]
      hasRsaPublicKey <- c.downField("has_rsa_public_key").as[Option[Boolean]]
      rsaPublicKeyFp <- c.downField("rsa_public_key_fp").as[Option[String]]
      rsaPublicKey2Fp <- c.downField("rsa_public_key_2_fp").as[Option[String]]
      extAuthnDuo <- c.downField("ext_authn_duo").as[Option[Boolean]]
      extAuthnUid <- c.downField("ext_authn_uid").as[Option[String]]
      owner <- c.downField("owner").as[Option[String]]
      snowflakeLock <- c.downField("snowflake_lock").as[Option[Boolean]]
      snowflakeSupport <- c.downField("snowflake_support").as[Option[Boolean]]
      minsToBypassNetworkPolicy <- c.downField("mins_to_bypass_network_policy").as[Option[Int]]
      passwordLastSet <- c.downField("password_last_set").as[Option[Instant]]
      customLandingPageUrl <- c.downField("custom_landing_page_url").as[Option[String]]
      customLandingPageUrlFlushNextUiLoad <- c.downField("custom_landing_page_url_flush_next_ui_load").as[Option[Boolean]]
    } yield User(
      name = name,
      password = password,
      loginName = loginName,
      displayName = displayName,
      firstName = firstName,
      middleName = middleName,
      lastName = lastName,
      email = email,
      mustChangePassword = mustChangePassword,
      disabled = disabled,
      daysToExpiry = daysToExpiry,
      minsToUnlock = minsToUnlock,
      defaultWarehouse = defaultWarehouse,
      defaultNamespace = defaultNamespace,
      defaultRole = defaultRole,
      defaultSecondaryRoles = defaultSecondaryRoles,
      minsToBypassMfa = minsToBypassMfa,
      rsaPublicKey = rsaPublicKey,
      rsaPublicKey2 = rsaPublicKey2,
      comment = comment,
      `type` = `type`,
      enableUnredactedQuerySyntaxError = enableUnredactedQuerySyntaxError,
      networkPolicy = networkPolicy,
      createdOn = createdOn,
      lastSuccessfulLogin = lastSuccessfulLogin,
      expiresAt = expiresAt,
      lockedUntil = lockedUntil,
      hasPassword = hasPassword,
      hasRsaPublicKey = hasRsaPublicKey,
      rsaPublicKeyFp = rsaPublicKeyFp,
      rsaPublicKey2Fp = rsaPublicKey2Fp,
      extAuthnDuo = extAuthnDuo,
      extAuthnUid = extAuthnUid,
      owner = owner,
      snowflakeLock = snowflakeLock,
      snowflakeSupport = snowflakeSupport,
      minsToBypassNetworkPolicy = minsToBypassNetworkPolicy,
      passwordLastSet = passwordLastSet,
      customLandingPageUrl = customLandingPageUrl,
      customLandingPageUrlFlushNextUiLoad = customLandingPageUrlFlushNextUiLoad
    )
  }
}

